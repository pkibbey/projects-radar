import { NextRequest } from "next/server";
import { getGitHubToken } from "@/lib/env";
import { cloneRepoForAnalysis, cleanupRepo } from "@/lib/repo-cloner";
import { enhancePackageJson } from "@/lib/ai";
import db from "@/lib/db";
import * as fs from "fs/promises";
import * as path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

/**
 * POST /api/repos/[owner]/[repo]/package-json
 * Clones the repo, reads package.json, enhances it with AI, saves it back, and updates the database
 */
export async function POST(
  _request: NextRequest,
  context: { params: Promise<{ owner: string; repo: string }> },
) {
  const { owner, repo } = await context.params;

  const token = getGitHubToken();
  if (!token) {
    return new Response(JSON.stringify({ error: "GITHUB_TOKEN is required to clean package.json." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  let repoPath: string | null = null;

  try {
    // Clone repository for local file access
    console.log(`Cloning repository ${owner}/${repo} for package.json cleaning...`);
    repoPath = await cloneRepoForAnalysis(owner, repo, token);

    // Read package.json
    const packageJsonPath = path.join(repoPath, "package.json");
    
    try {
      await fs.access(packageJsonPath);
    } catch {
      return new Response(JSON.stringify({ error: "package.json not found in repository." }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    const packageJsonContent = await fs.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);

    // Read README if it exists for better context
    let readmeContent: string | undefined;
    try {
      const readmePath = path.join(repoPath, "README.md");
      readmeContent = await fs.readFile(readmePath, "utf-8");
    } catch {
      // README is optional
    }

    // Generate enhancements using AI
    console.log(`Enhancing package.json for ${owner}/${repo} with AI...`);
    const enhancements = await enhancePackageJson(packageJson, owner, repo, readmeContent);

    // Merge enhancements into package.json (preserving existing fields)
    const updatedPackageJson = {
      ...packageJson,
      description: enhancements.description,
      keywords: enhancements.keywords,
      homepage: enhancements.homepage,
      repository: enhancements.repository,
      bugs: enhancements.bugs,
    };

    // Only add author if it was provided and doesn't already exist
    if (enhancements.author && !packageJson.author) {
      updatedPackageJson.author = enhancements.author;
    }

    // Save the updated package.json back to the file system
    await fs.writeFile(
      packageJsonPath,
      JSON.stringify(updatedPackageJson, null, 2) + "\n",
      "utf-8"
    );

    console.log(`Updated package.json for ${owner}/${repo}`);

    // Commit and push changes to GitHub
    try {
      // Configure git user for the commit
      await execAsync(`git config user.email "bot@projects-dashboard.local"`, { cwd: repoPath });
      await execAsync(`git config user.name "Projects Dashboard Bot"`, { cwd: repoPath });
      
      // Add the changes
      await execAsync(`git add package.json`, { cwd: repoPath });
      
      // Commit the changes
      const commitMessage = `chore: enhance package.json with AI-generated metadata

- Updated description
- Added keywords
- Added repository, homepage, and bugs URLs
${enhancements.author ? `- Added author information` : ''}

Generated by Projects Dashboard`;
      
      await execAsync(`git commit -m "${commitMessage.replace(/"/g, '\\"')}"`, { cwd: repoPath });
      
      // Push to GitHub
      await execAsync(`git push origin HEAD:main`, { cwd: repoPath });
      
      console.log(`Successfully pushed package.json changes to ${owner}/${repo}`);
    } catch (gitError) {
      console.error("Git operation failed:", gitError);
      // Continue even if git operations fail - we still updated the database
      return new Response(
        JSON.stringify({
          ok: true,
          message: "package.json enhanced successfully (local only)",
          enhancements,
          warning: "Could not push changes to GitHub. You may need to commit and push manually.",
          error: gitError instanceof Error ? gitError.message : "Git operation failed",
        }),
        {
          status: 200,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    // Update the description in the database
    const existingData = await db.getRepoData(owner, repo);
    if (existingData) {
      await db.updateRepoDescription(owner, repo, enhancements.description);
    }

    return new Response(
      JSON.stringify({
        ok: true,
        message: "package.json enhanced and pushed to GitHub successfully! âœ¨",
        enhancements,
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" },
      }
    );
  } catch (error) {
    console.error(`Failed to clean package.json for ${owner}/${repo}:`, error);
    const message = error instanceof Error ? error.message : "Unknown error";
    return new Response(JSON.stringify({ error: message }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  } finally {
    // Clean up the cloned repository
    if (repoPath) {
      await cleanupRepo(repoPath);
    }
  }
}
